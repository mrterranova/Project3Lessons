{"ast":null,"code":"import _objectSpread from \"C:\\\\Users\\\\User\\\\Desktop\\\\MERN Passport\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread2\";\nimport _objectWithoutProperties from \"C:\\\\Users\\\\User\\\\Desktop\\\\MERN Passport\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectWithoutProperties\";\nvar _jsxFileName = \"C:\\\\Users\\\\User\\\\Desktop\\\\MERN Passport\\\\client\\\\src\\\\core\\\\pages\\\\Admin\\\\components\\\\PracticeDraft.js\";\nimport React, { Component } from 'react';\nimport { CompositeDecorator, Editor, EditorState, Modifier, RichUtils, Entity } from 'draft-js';\nimport getDefaultKeyBinding from 'draft-js/lib/getDefaultKeyBinding';\nimport changeBlockDepth from './lib/changeBlockDepth';\nimport changeBlockType from './lib/changeBlockType';\nimport getBlocksInSelection from './lib/getBlocksInSelection';\nimport insertBlockAfter from './lib/insertBlockAfter';\nimport isListItem from './lib/isListItem';\nimport isSoftNewlineEvent from 'draft-js/lib/isSoftNewlineEvent';\nimport EditorToolbar from './lib/EditorToolbar';\nimport EditorValue from './lib/EditorValue';\nimport LinkDecorator from './lib/LinkDecorator';\nimport ImageDecorator from './lib/ImageDecorator';\nimport composite from './lib/composite';\nimport cx from 'classnames';\nimport autobind from 'class-autobind';\nimport EventEmitter from 'events';\nimport { BLOCK_TYPE } from 'draft-js-utils';\nimport './Draft.global.css';\nimport styles from './RichTextEditor.css';\nimport ButtonGroup from './ui/ButtonGroup';\nimport Button from './ui/Button';\nimport Dropdown from './ui/Dropdown';\nconst MAX_LIST_DEPTH = 2; // Custom overrides for \"code\" style.\n\nconst styleMap = {\n  CODE: {\n    backgroundColor: '#f3f3f3',\n    fontFamily: '\"Inconsolata\", \"Menlo\", \"Consolas\", monospace',\n    fontSize: 16,\n    padding: 2\n  }\n};\nexport default class RichTextEditor extends Component {\n  constructor() {\n    super(...arguments);\n    this._keyEmitter = new EventEmitter();\n    autobind(this);\n  }\n\n  componentDidMount() {\n    const autoFocus = this.props.autoFocus;\n\n    if (!autoFocus) {\n      return;\n    }\n\n    this._focus();\n  }\n\n  render() {\n    let _this$props = this.props,\n        value = _this$props.value,\n        className = _this$props.className,\n        toolbarClassName = _this$props.toolbarClassName,\n        editorClassName = _this$props.editorClassName,\n        placeholder = _this$props.placeholder,\n        customStyleMap = _this$props.customStyleMap,\n        readOnly = _this$props.readOnly,\n        disabled = _this$props.disabled,\n        toolbarConfig = _this$props.toolbarConfig,\n        toolbarOnBottom = _this$props.toolbarOnBottom,\n        blockStyleFn = _this$props.blockStyleFn,\n        customControls = _this$props.customControls,\n        keyBindingFn = _this$props.keyBindingFn,\n        rootStyle = _this$props.rootStyle,\n        toolbarStyle = _this$props.toolbarStyle,\n        editorStyle = _this$props.editorStyle,\n        otherProps = _objectWithoutProperties(_this$props, [\"value\", \"className\", \"toolbarClassName\", \"editorClassName\", \"placeholder\", \"customStyleMap\", \"readOnly\", \"disabled\", \"toolbarConfig\", \"toolbarOnBottom\", \"blockStyleFn\", \"customControls\", \"keyBindingFn\", \"rootStyle\", \"toolbarStyle\", \"editorStyle\"]);\n\n    let editorState = value.getEditorState();\n    customStyleMap = customStyleMap ? _objectSpread({}, styleMap, {}, customStyleMap) : styleMap; // If the user changes block type before entering any text, we can either\n    // style the placeholder or hide it. Let's just hide it for now.\n\n    let combinedEditorClassName = cx({\n      [styles.editor]: true,\n      [styles.hidePlaceholder]: this._shouldHidePlaceholder()\n    }, editorClassName);\n\n    if (readOnly == null) {\n      readOnly = disabled;\n    }\n\n    let editorToolbar;\n\n    if (!readOnly) {\n      editorToolbar = React.createElement(EditorToolbar, {\n        rootStyle: toolbarStyle,\n        isOnBottom: toolbarOnBottom,\n        className: toolbarClassName,\n        keyEmitter: this._keyEmitter,\n        editorState: editorState,\n        onChange: this._onChange,\n        focusEditor: this._focus,\n        toolbarConfig: toolbarConfig,\n        customControls: customControls,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 123\n        },\n        __self: this\n      });\n    }\n\n    return React.createElement(\"div\", {\n      className: cx(styles.root, className),\n      style: rootStyle,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 137\n      },\n      __self: this\n    }, !toolbarOnBottom && editorToolbar, React.createElement(\"div\", {\n      className: combinedEditorClassName,\n      style: editorStyle,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 139\n      },\n      __self: this\n    }, React.createElement(Editor, Object.assign({}, otherProps, {\n      blockStyleFn: composite(defaultBlockStyleFn, blockStyleFn),\n      customStyleMap: customStyleMap,\n      editorState: editorState,\n      handleReturn: this._handleReturn,\n      keyBindingFn: keyBindingFn || this._customKeyHandler,\n      handleKeyCommand: this._handleKeyCommand,\n      onTab: this._onTab,\n      onChange: this._onChange,\n      placeholder: placeholder,\n      ref: el => {\n        this.editor = el;\n      },\n      spellCheck: true,\n      readOnly: readOnly,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 140\n      },\n      __self: this\n    }))), toolbarOnBottom && editorToolbar);\n  }\n\n  _shouldHidePlaceholder() {\n    let editorState = this.props.value.getEditorState();\n    let contentState = editorState.getCurrentContent();\n\n    if (!contentState.hasText()) {\n      if (contentState.getBlockMap().first().getType() !== 'unstyled') {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  _handleReturn(event) {\n    let handleReturn = this.props.handleReturn;\n\n    if (handleReturn != null && handleReturn(event)) {\n      return true;\n    }\n\n    if (this._handleReturnSoftNewline(event)) {\n      return true;\n    }\n\n    if (this._handleReturnEmptyListItem()) {\n      return true;\n    }\n\n    if (this._handleReturnSpecialBlock()) {\n      return true;\n    }\n\n    return false;\n  } // `shift + return` should insert a soft newline.\n\n\n  _handleReturnSoftNewline(event) {\n    let editorState = this.props.value.getEditorState();\n\n    if (isSoftNewlineEvent(event)) {\n      let selection = editorState.getSelection();\n\n      if (selection.isCollapsed()) {\n        this._onChange(RichUtils.insertSoftNewline(editorState));\n      } else {\n        let content = editorState.getCurrentContent();\n        let newContent = Modifier.removeRange(content, selection, 'forward');\n        let newSelection = newContent.getSelectionAfter();\n        let block = newContent.getBlockForKey(newSelection.getStartKey());\n        newContent = Modifier.insertText(newContent, newSelection, '\\n', block.getInlineStyleAt(newSelection.getStartOffset()), null);\n\n        this._onChange(EditorState.push(editorState, newContent, 'insert-fragment'));\n      }\n\n      return true;\n    }\n\n    return false;\n  } // If the cursor is in an empty list item when return is pressed, then the\n  // block type should change to normal (end the list).\n\n\n  _handleReturnEmptyListItem() {\n    let editorState = this.props.value.getEditorState();\n    let selection = editorState.getSelection();\n\n    if (selection.isCollapsed()) {\n      let contentState = editorState.getCurrentContent();\n      let blockKey = selection.getStartKey();\n      let block = contentState.getBlockForKey(blockKey);\n\n      if (isListItem(block) && block.getLength() === 0) {\n        let depth = block.getDepth();\n        let newState = depth === 0 ? changeBlockType(editorState, blockKey, BLOCK_TYPE.UNSTYLED) : changeBlockDepth(editorState, blockKey, depth - 1);\n\n        this._onChange(newState);\n\n        return true;\n      }\n    }\n\n    return false;\n  } // If the cursor is at the end of a special block (any block type other than\n  // normal or list item) when return is pressed, new block should be normal.\n\n\n  _handleReturnSpecialBlock() {\n    let editorState = this.props.value.getEditorState();\n    let selection = editorState.getSelection();\n\n    if (selection.isCollapsed()) {\n      let contentState = editorState.getCurrentContent();\n      let blockKey = selection.getStartKey();\n      let block = contentState.getBlockForKey(blockKey);\n\n      if (!isListItem(block) && block.getType() !== BLOCK_TYPE.UNSTYLED) {\n        // If cursor is at end.\n        if (block.getLength() === selection.getStartOffset()) {\n          let newEditorState = insertBlockAfter(editorState, blockKey, BLOCK_TYPE.UNSTYLED);\n\n          this._onChange(newEditorState);\n\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  _onTab(event) {\n    let editorState = this.props.value.getEditorState();\n    let newEditorState = RichUtils.onTab(event, editorState, MAX_LIST_DEPTH);\n\n    if (newEditorState !== editorState) {\n      this._onChange(newEditorState);\n    }\n  }\n\n  _customKeyHandler(event) {\n    // Allow toolbar to catch key combinations.\n    let eventFlags = {};\n\n    this._keyEmitter.emit('keypress', event, eventFlags);\n\n    if (eventFlags.wasHandled) {\n      return null;\n    } else {\n      return getDefaultKeyBinding(event);\n    }\n  }\n\n  _handleKeyCommand(command) {\n    let editorState = this.props.value.getEditorState();\n    let newEditorState = RichUtils.handleKeyCommand(editorState, command);\n\n    if (newEditorState) {\n      this._onChange(newEditorState);\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  _onChange(editorState) {\n    let _this$props2 = this.props,\n        onChange = _this$props2.onChange,\n        value = _this$props2.value;\n\n    if (onChange == null) {\n      return;\n    }\n\n    let newValue = value.setEditorState(editorState);\n    let newEditorState = newValue.getEditorState();\n\n    this._handleInlineImageSelection(newEditorState);\n\n    onChange(newValue);\n  }\n\n  _handleInlineImageSelection(editorState) {\n    let selection = editorState.getSelection();\n    let blocks = getBlocksInSelection(editorState);\n\n    const selectImage = (block, offset) => {\n      const imageKey = block.getEntityAt(offset);\n      Entity.mergeData(imageKey, {\n        selected: true\n      });\n    };\n\n    let isInMiddleBlock = index => index > 0 && index < blocks.size - 1;\n\n    let isWithinStartBlockSelection = (offset, index) => index === 0 && offset > selection.getStartOffset();\n\n    let isWithinEndBlockSelection = (offset, index) => index === blocks.size - 1 && offset < selection.getEndOffset();\n\n    blocks.toIndexedSeq().forEach((block, index) => {\n      ImageDecorator.strategy(block, offset => {\n        if (isWithinStartBlockSelection(offset, index) || isInMiddleBlock(index) || isWithinEndBlockSelection(offset, index)) {\n          selectImage(block, offset);\n        }\n      });\n    });\n  }\n\n  _focus() {\n    this.editor.focus();\n  }\n\n}\n\nfunction defaultBlockStyleFn(block) {\n  let result = styles.block;\n\n  switch (block.getType()) {\n    case 'unstyled':\n      return cx(result, styles.paragraph);\n\n    case 'blockquote':\n      return cx(result, styles.blockquote);\n\n    case 'code-block':\n      return cx(result, styles.codeBlock);\n\n    default:\n      return result;\n  }\n}\n\nconst decorator = new CompositeDecorator([LinkDecorator, ImageDecorator]);\n\nfunction createEmptyValue() {\n  return EditorValue.createEmpty(decorator);\n}\n\nfunction createValueFromString(markup, format, options) {\n  return EditorValue.createFromString(markup, format, decorator, options);\n} // $FlowIssue - This should probably not be done this way.\n\n\nObject.assign(RichTextEditor, {\n  EditorValue,\n  decorator,\n  createEmptyValue,\n  createValueFromString,\n  ButtonGroup,\n  Button,\n  Dropdown\n});\nexport { EditorValue, decorator, createEmptyValue, createValueFromString, ButtonGroup, Button, Dropdown };","map":{"version":3,"sources":["C:/Users/User/Desktop/MERN Passport/client/src/core/pages/Admin/components/PracticeDraft.js"],"names":["React","Component","CompositeDecorator","Editor","EditorState","Modifier","RichUtils","Entity","getDefaultKeyBinding","changeBlockDepth","changeBlockType","getBlocksInSelection","insertBlockAfter","isListItem","isSoftNewlineEvent","EditorToolbar","EditorValue","LinkDecorator","ImageDecorator","composite","cx","autobind","EventEmitter","BLOCK_TYPE","styles","ButtonGroup","Button","Dropdown","MAX_LIST_DEPTH","styleMap","CODE","backgroundColor","fontFamily","fontSize","padding","RichTextEditor","constructor","arguments","_keyEmitter","componentDidMount","autoFocus","props","_focus","render","value","className","toolbarClassName","editorClassName","placeholder","customStyleMap","readOnly","disabled","toolbarConfig","toolbarOnBottom","blockStyleFn","customControls","keyBindingFn","rootStyle","toolbarStyle","editorStyle","otherProps","editorState","getEditorState","combinedEditorClassName","editor","hidePlaceholder","_shouldHidePlaceholder","editorToolbar","_onChange","root","defaultBlockStyleFn","_handleReturn","_customKeyHandler","_handleKeyCommand","_onTab","el","contentState","getCurrentContent","hasText","getBlockMap","first","getType","event","handleReturn","_handleReturnSoftNewline","_handleReturnEmptyListItem","_handleReturnSpecialBlock","selection","getSelection","isCollapsed","insertSoftNewline","content","newContent","removeRange","newSelection","getSelectionAfter","block","getBlockForKey","getStartKey","insertText","getInlineStyleAt","getStartOffset","push","blockKey","getLength","depth","getDepth","newState","UNSTYLED","newEditorState","onTab","eventFlags","emit","wasHandled","command","handleKeyCommand","onChange","newValue","setEditorState","_handleInlineImageSelection","blocks","selectImage","offset","imageKey","getEntityAt","mergeData","selected","isInMiddleBlock","index","size","isWithinStartBlockSelection","isWithinEndBlockSelection","getEndOffset","toIndexedSeq","forEach","strategy","focus","result","paragraph","blockquote","codeBlock","decorator","createEmptyValue","createEmpty","createValueFromString","markup","format","options","createFromString","Object","assign"],"mappings":"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","sourcesContent":["import React, {Component} from 'react';\r\nimport {CompositeDecorator, Editor, EditorState, Modifier, RichUtils, Entity} from 'draft-js';\r\nimport getDefaultKeyBinding from 'draft-js/lib/getDefaultKeyBinding';\r\nimport changeBlockDepth from './lib/changeBlockDepth';\r\nimport changeBlockType from './lib/changeBlockType';\r\nimport getBlocksInSelection from './lib/getBlocksInSelection';\r\nimport insertBlockAfter from './lib/insertBlockAfter';\r\nimport isListItem from './lib/isListItem';\r\nimport isSoftNewlineEvent from 'draft-js/lib/isSoftNewlineEvent';\r\nimport EditorToolbar from './lib/EditorToolbar';\r\nimport EditorValue from './lib/EditorValue';\r\nimport LinkDecorator from './lib/LinkDecorator';\r\nimport ImageDecorator from './lib/ImageDecorator';\r\nimport composite from './lib/composite';\r\nimport cx from 'classnames';\r\nimport autobind from 'class-autobind';\r\nimport EventEmitter from 'events';\r\nimport {BLOCK_TYPE} from 'draft-js-utils';\r\n\r\nimport './Draft.global.css';\r\nimport styles from './RichTextEditor.css';\r\n\r\nimport type {ContentBlock} from 'draft-js';\r\nimport type {ToolbarConfig, CustomControl} from './lib/EditorToolbarConfig';\r\nimport type {ImportOptions} from './lib/EditorValue';\r\n\r\nimport ButtonGroup from './ui/ButtonGroup';\r\nimport Button from './ui/Button';\r\nimport Dropdown from './ui/Dropdown';\r\n\r\nconst MAX_LIST_DEPTH = 2;\r\n\r\n// Custom overrides for \"code\" style.\r\nconst styleMap = {\r\n  CODE: {\r\n    backgroundColor: '#f3f3f3',\r\n    fontFamily: '\"Inconsolata\", \"Menlo\", \"Consolas\", monospace',\r\n    fontSize: 16,\r\n    padding: 2,\r\n  },\r\n};\r\n\r\ntype ChangeHandler = (value: EditorValue) => any;\r\n\r\ntype Props = {\r\n  className?: string;\r\n  toolbarClassName?: string;\r\n  editorClassName?: string;\r\n  value: EditorValue;\r\n  onChange?: ChangeHandler;\r\n  placeholder?: string;\r\n  customStyleMap?: {[style: string]: {[key: string]: any}};\r\n  handleReturn?: (event: Object) => boolean;\r\n  customControls?: Array<CustomControl>;\r\n  readOnly?: boolean;\r\n  disabled?: boolean; // Alias of readOnly\r\n  toolbarConfig?: ToolbarConfig;\r\n  toolbarOnBottom?: boolean;\r\n  blockStyleFn?: (block: ContentBlock) => ?string;\r\n  autoFocus?: boolean;\r\n  keyBindingFn?: (event: Object) => ?string;\r\n  rootStyle?: Object;\r\n  editorStyle?: Object;\r\n  toolbarStyle?: Object;\r\n};\r\n\r\nexport default class RichTextEditor extends Component {\r\n  props: Props;\r\n  _keyEmitter: EventEmitter;\r\n  editor: HTMLDivElement;\r\n\r\n  constructor() {\r\n    super(...arguments);\r\n    this._keyEmitter = new EventEmitter();\r\n    autobind(this);\r\n  }\r\n\r\n  componentDidMount() {\r\n    const {autoFocus} = this.props;\r\n\r\n    if (!autoFocus) {\r\n      return;\r\n    }\r\n\r\n    this._focus();\r\n  }\r\n\r\n  render() {\r\n    let {\r\n      value,\r\n      className,\r\n      toolbarClassName,\r\n      editorClassName,\r\n      placeholder,\r\n      customStyleMap,\r\n      readOnly,\r\n      disabled,\r\n      toolbarConfig,\r\n      toolbarOnBottom,\r\n      blockStyleFn,\r\n      customControls,\r\n      keyBindingFn,\r\n      rootStyle,\r\n      toolbarStyle,\r\n      editorStyle,\r\n      ...otherProps // eslint-disable-line comma-dangle\r\n    } = this.props;\r\n    let editorState = value.getEditorState();\r\n    customStyleMap = customStyleMap ? {...styleMap, ...customStyleMap} : styleMap;\r\n\r\n    // If the user changes block type before entering any text, we can either\r\n    // style the placeholder or hide it. Let's just hide it for now.\r\n    let combinedEditorClassName = cx({\r\n      [styles.editor]: true,\r\n      [styles.hidePlaceholder]: this._shouldHidePlaceholder(),\r\n    }, editorClassName);\r\n    if (readOnly == null) {\r\n      readOnly = disabled;\r\n    }\r\n    let editorToolbar;\r\n    if (!readOnly) {\r\n      editorToolbar = (\r\n        <EditorToolbar\r\n          rootStyle={toolbarStyle}\r\n          isOnBottom={toolbarOnBottom}\r\n          className={toolbarClassName}\r\n          keyEmitter={this._keyEmitter}\r\n          editorState={editorState}\r\n          onChange={this._onChange}\r\n          focusEditor={this._focus}\r\n          toolbarConfig={toolbarConfig}\r\n          customControls={customControls}\r\n        />\r\n      );\r\n    }\r\n    return (\r\n      <div className={cx(styles.root, className)} style={rootStyle}>\r\n        { !toolbarOnBottom && editorToolbar }\r\n        <div className={combinedEditorClassName} style={editorStyle}>\r\n          <Editor\r\n            {...otherProps}\r\n            blockStyleFn={composite(defaultBlockStyleFn, blockStyleFn)}\r\n            customStyleMap={customStyleMap}\r\n            editorState={editorState}\r\n            handleReturn={this._handleReturn}\r\n            keyBindingFn={keyBindingFn || this._customKeyHandler}\r\n            handleKeyCommand={this._handleKeyCommand}\r\n            onTab={this._onTab}\r\n            onChange={this._onChange}\r\n            placeholder={placeholder}\r\n            ref={(el) => {\r\n              this.editor = el;\r\n            }}\r\n            spellCheck={true}\r\n            readOnly={readOnly}\r\n          />\r\n        </div>\r\n        { toolbarOnBottom && editorToolbar }\r\n      </div>\r\n    );\r\n  }\r\n\r\n  _shouldHidePlaceholder(): boolean {\r\n    let editorState = this.props.value.getEditorState();\r\n    let contentState = editorState.getCurrentContent();\r\n    if (!contentState.hasText()) {\r\n      if (contentState.getBlockMap().first().getType() !== 'unstyled') {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  _handleReturn(event: Object): boolean {\r\n    let {handleReturn} = this.props;\r\n    if (handleReturn != null && handleReturn(event)) {\r\n      return true;\r\n    }\r\n    if (this._handleReturnSoftNewline(event)) {\r\n      return true;\r\n    }\r\n    if (this._handleReturnEmptyListItem()) {\r\n      return true;\r\n    }\r\n    if (this._handleReturnSpecialBlock()) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  // `shift + return` should insert a soft newline.\r\n  _handleReturnSoftNewline(event: Object): boolean {\r\n    let editorState = this.props.value.getEditorState();\r\n    if (isSoftNewlineEvent(event)) {\r\n      let selection = editorState.getSelection();\r\n      if (selection.isCollapsed()) {\r\n        this._onChange(RichUtils.insertSoftNewline(editorState));\r\n      } else {\r\n        let content = editorState.getCurrentContent();\r\n        let newContent = Modifier.removeRange(content, selection, 'forward');\r\n        let newSelection = newContent.getSelectionAfter();\r\n        let block = newContent.getBlockForKey(newSelection.getStartKey());\r\n        newContent = Modifier.insertText(\r\n          newContent,\r\n          newSelection,\r\n          '\\n',\r\n          block.getInlineStyleAt(newSelection.getStartOffset()),\r\n          null,\r\n        );\r\n        this._onChange(\r\n          EditorState.push(editorState, newContent, 'insert-fragment')\r\n        );\r\n      }\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  // If the cursor is in an empty list item when return is pressed, then the\r\n  // block type should change to normal (end the list).\r\n  _handleReturnEmptyListItem(): boolean {\r\n    let editorState = this.props.value.getEditorState();\r\n    let selection = editorState.getSelection();\r\n    if (selection.isCollapsed()) {\r\n      let contentState = editorState.getCurrentContent();\r\n      let blockKey = selection.getStartKey();\r\n      let block = contentState.getBlockForKey(blockKey);\r\n      if (isListItem(block) && block.getLength() === 0) {\r\n        let depth = block.getDepth();\r\n        let newState = (depth === 0) ?\r\n          changeBlockType(editorState, blockKey, BLOCK_TYPE.UNSTYLED) :\r\n          changeBlockDepth(editorState, blockKey, depth - 1);\r\n        this._onChange(newState);\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  // If the cursor is at the end of a special block (any block type other than\r\n  // normal or list item) when return is pressed, new block should be normal.\r\n  _handleReturnSpecialBlock(): boolean {\r\n    let editorState = this.props.value.getEditorState();\r\n    let selection = editorState.getSelection();\r\n    if (selection.isCollapsed()) {\r\n      let contentState = editorState.getCurrentContent();\r\n      let blockKey = selection.getStartKey();\r\n      let block = contentState.getBlockForKey(blockKey);\r\n      if (!isListItem(block) && block.getType() !== BLOCK_TYPE.UNSTYLED) {\r\n        // If cursor is at end.\r\n        if (block.getLength() === selection.getStartOffset()) {\r\n          let newEditorState = insertBlockAfter(\r\n            editorState,\r\n            blockKey,\r\n            BLOCK_TYPE.UNSTYLED\r\n          );\r\n          this._onChange(newEditorState);\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  _onTab(event: Object): ?string {\r\n    let editorState = this.props.value.getEditorState();\r\n    let newEditorState = RichUtils.onTab(event, editorState, MAX_LIST_DEPTH);\r\n    if (newEditorState !== editorState) {\r\n      this._onChange(newEditorState);\r\n    }\r\n  }\r\n\r\n  _customKeyHandler(event: Object): ?string {\r\n    // Allow toolbar to catch key combinations.\r\n    let eventFlags = {};\r\n    this._keyEmitter.emit('keypress', event, eventFlags);\r\n    if (eventFlags.wasHandled) {\r\n      return null;\r\n    } else {\r\n      return getDefaultKeyBinding(event);\r\n    }\r\n  }\r\n\r\n  _handleKeyCommand(command: string): boolean {\r\n    let editorState = this.props.value.getEditorState();\r\n    let newEditorState = RichUtils.handleKeyCommand(editorState, command);\r\n    if (newEditorState) {\r\n      this._onChange(newEditorState);\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  _onChange(editorState: EditorState) {\r\n    let {onChange, value} = this.props;\r\n    if (onChange == null) {\r\n      return;\r\n    }\r\n    let newValue = value.setEditorState(editorState);\r\n    let newEditorState = newValue.getEditorState();\r\n    this._handleInlineImageSelection(newEditorState);\r\n    onChange(newValue);\r\n  }\r\n\r\n  _handleInlineImageSelection(editorState: EditorState) {\r\n    let selection = editorState.getSelection();\r\n    let blocks = getBlocksInSelection(editorState);\r\n\r\n    const selectImage = (block, offset) => {\r\n      const imageKey = block.getEntityAt(offset);\r\n      Entity.mergeData(imageKey, {selected: true});\r\n    };\r\n\r\n    let isInMiddleBlock = (index) => index > 0 && index < blocks.size - 1;\r\n    let isWithinStartBlockSelection = (offset, index) => (\r\n      index === 0 && offset > selection.getStartOffset()\r\n    );\r\n    let isWithinEndBlockSelection = (offset, index) => (\r\n      index === blocks.size - 1 && offset < selection.getEndOffset()\r\n    );\r\n\r\n    blocks.toIndexedSeq().forEach((block, index) => {\r\n      ImageDecorator.strategy(\r\n        block,\r\n        (offset) => {\r\n          if (isWithinStartBlockSelection(offset, index) ||\r\n              isInMiddleBlock(index) ||\r\n              isWithinEndBlockSelection(offset, index)) {\r\n            selectImage(block, offset);\r\n          }\r\n        });\r\n    });\r\n  }\r\n\r\n  _focus() {\r\n    this.editor.focus();\r\n  }\r\n}\r\n\r\nfunction defaultBlockStyleFn(block: ContentBlock): string {\r\n  let result = styles.block;\r\n  switch (block.getType()) {\r\n    case 'unstyled':\r\n      return cx(result, styles.paragraph);\r\n    case 'blockquote':\r\n      return cx(result, styles.blockquote);\r\n    case 'code-block':\r\n      return cx(result, styles.codeBlock);\r\n    default:\r\n      return result;\r\n  }\r\n}\r\n\r\nconst decorator = new CompositeDecorator([LinkDecorator, ImageDecorator]);\r\n\r\nfunction createEmptyValue(): EditorValue {\r\n  return EditorValue.createEmpty(decorator);\r\n}\r\n\r\nfunction createValueFromString(markup: string, format: string, options?: ImportOptions): EditorValue {\r\n  return EditorValue.createFromString(markup, format, decorator, options);\r\n}\r\n\r\n// $FlowIssue - This should probably not be done this way.\r\nObject.assign(RichTextEditor, {\r\n  EditorValue,\r\n  decorator,\r\n  createEmptyValue,\r\n  createValueFromString,\r\n  ButtonGroup,\r\n  Button,\r\n  Dropdown,\r\n});\r\n\r\nexport {\r\n  EditorValue,\r\n  decorator,\r\n  createEmptyValue,\r\n  createValueFromString,\r\n  ButtonGroup,\r\n  Button,\r\n  Dropdown,\r\n};"]},"metadata":{},"sourceType":"module"}