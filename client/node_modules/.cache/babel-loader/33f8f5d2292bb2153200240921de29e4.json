{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nexports.default = function (editorState, selection, type, data) {\n  var text = arguments.length <= 4 || arguments[4] === undefined ? ' ' : arguments[4];\n  var currentContentState = editorState.getCurrentContent();\n  var currentSelectionState = selection; // in case text is selected it is removed and then the block is appended\n\n  var afterRemovalContentState = _draftJs.Modifier.removeRange(currentContentState, currentSelectionState, 'backward'); // deciding on the postion to split the text\n\n\n  var targetSelection = afterRemovalContentState.getSelectionAfter();\n  var blockKeyForTarget = targetSelection.get('focusKey');\n  var block = currentContentState.getBlockForKey(blockKeyForTarget);\n  var insertionTargetSelection = void 0;\n  var insertionTargetBlock = void 0; // In case there are no characters or entity or the selection is at the start it\n  // is safe to insert the block in the current block.\n  // Otherwise a new block is created (the block is always its own block)\n\n  var isEmptyBlock = block.getLength() === 0 && block.getEntityAt(0) === null;\n  var selectedFromStart = currentSelectionState.getStartOffset() === 0;\n\n  if (isEmptyBlock || selectedFromStart) {\n    insertionTargetSelection = targetSelection;\n    insertionTargetBlock = afterRemovalContentState;\n  } else {\n    // the only way to insert a new seems to be by splitting an existing in to two\n    insertionTargetBlock = _draftJs.Modifier.splitBlock(afterRemovalContentState, targetSelection); // the position to insert our blocks\n\n    insertionTargetSelection = insertionTargetBlock.getSelectionAfter();\n  } // TODO not sure why we need it …\n\n\n  var newContentStateAfterSplit = _draftJs.Modifier.setBlockType(insertionTargetBlock, insertionTargetSelection, type); // creating a new ContentBlock including the entity with data\n\n\n  var entityKey = _draftJs.Entity.create(type, 'IMMUTABLE', _extends({}, data));\n\n  var charData = _draftJs.CharacterMetadata.create({\n    entity: entityKey\n  });\n\n  var fragmentArray = [new _draftJs.ContentBlock({\n    key: (0, _draftJs.genKey)(),\n    type: type,\n    text: text,\n    characterList: (0, _immutable.List)((0, _immutable.Repeat)(charData, text.length || 1))\n  }), // new contentblock so we can continue wrting right away after inserting the block\n  new _draftJs.ContentBlock({\n    key: (0, _draftJs.genKey)(),\n    type: 'unstyled',\n    text: '',\n    characterList: (0, _immutable.List)()\n  })]; // create fragment containing the two content blocks\n\n  var fragment = _draftJs.BlockMapBuilder.createFromArray(fragmentArray); // replace the contentblock we reserved for our insert\n\n\n  var contentStateWithBlock = _draftJs.Modifier.replaceWithFragment(newContentStateAfterSplit, insertionTargetSelection, fragment); // update editor state with our new state including the block\n\n\n  var newState = _draftJs.EditorState.push(editorState, contentStateWithBlock, 'insert-' + type);\n\n  return _draftJs.EditorState.forceSelection(newState, contentStateWithBlock.getSelectionAfter());\n};\n\nvar _immutable = require('immutable');\n\nvar _draftJs = require('draft-js');","map":{"version":3,"sources":["C:/Users/User/Desktop/MERN Passport/client/node_modules/draft-js-dnd-plugin/lib/modifiers/addBlock.js"],"names":["Object","defineProperty","exports","value","_extends","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","default","editorState","selection","type","data","text","undefined","currentContentState","getCurrentContent","currentSelectionState","afterRemovalContentState","_draftJs","Modifier","removeRange","targetSelection","getSelectionAfter","blockKeyForTarget","get","block","getBlockForKey","insertionTargetSelection","insertionTargetBlock","isEmptyBlock","getLength","getEntityAt","selectedFromStart","getStartOffset","splitBlock","newContentStateAfterSplit","setBlockType","entityKey","Entity","create","charData","CharacterMetadata","entity","fragmentArray","ContentBlock","genKey","characterList","_immutable","List","Repeat","fragment","BlockMapBuilder","createFromArray","contentStateWithBlock","replaceWithFragment","newState","EditorState","push","forceSelection","require"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexports.default = function (editorState, selection, type, data) {\n  var text = arguments.length <= 4 || arguments[4] === undefined ? ' ' : arguments[4];\n\n  var currentContentState = editorState.getCurrentContent();\n  var currentSelectionState = selection;\n\n  // in case text is selected it is removed and then the block is appended\n  var afterRemovalContentState = _draftJs.Modifier.removeRange(currentContentState, currentSelectionState, 'backward');\n\n  // deciding on the postion to split the text\n  var targetSelection = afterRemovalContentState.getSelectionAfter();\n  var blockKeyForTarget = targetSelection.get('focusKey');\n  var block = currentContentState.getBlockForKey(blockKeyForTarget);\n  var insertionTargetSelection = void 0;\n  var insertionTargetBlock = void 0;\n\n  // In case there are no characters or entity or the selection is at the start it\n  // is safe to insert the block in the current block.\n  // Otherwise a new block is created (the block is always its own block)\n  var isEmptyBlock = block.getLength() === 0 && block.getEntityAt(0) === null;\n  var selectedFromStart = currentSelectionState.getStartOffset() === 0;\n  if (isEmptyBlock || selectedFromStart) {\n    insertionTargetSelection = targetSelection;\n    insertionTargetBlock = afterRemovalContentState;\n  } else {\n    // the only way to insert a new seems to be by splitting an existing in to two\n    insertionTargetBlock = _draftJs.Modifier.splitBlock(afterRemovalContentState, targetSelection);\n\n    // the position to insert our blocks\n    insertionTargetSelection = insertionTargetBlock.getSelectionAfter();\n  }\n\n  // TODO not sure why we need it …\n  var newContentStateAfterSplit = _draftJs.Modifier.setBlockType(insertionTargetBlock, insertionTargetSelection, type);\n\n  // creating a new ContentBlock including the entity with data\n  var entityKey = _draftJs.Entity.create(type, 'IMMUTABLE', _extends({}, data));\n  var charData = _draftJs.CharacterMetadata.create({ entity: entityKey });\n\n  var fragmentArray = [new _draftJs.ContentBlock({\n    key: (0, _draftJs.genKey)(),\n    type: type,\n    text: text,\n    characterList: (0, _immutable.List)((0, _immutable.Repeat)(charData, text.length || 1)) }),\n\n  // new contentblock so we can continue wrting right away after inserting the block\n  new _draftJs.ContentBlock({\n    key: (0, _draftJs.genKey)(),\n    type: 'unstyled',\n    text: '',\n    characterList: (0, _immutable.List)() })];\n\n  // create fragment containing the two content blocks\n  var fragment = _draftJs.BlockMapBuilder.createFromArray(fragmentArray);\n\n  // replace the contentblock we reserved for our insert\n  var contentStateWithBlock = _draftJs.Modifier.replaceWithFragment(newContentStateAfterSplit, insertionTargetSelection, fragment);\n\n  // update editor state with our new state including the block\n  var newState = _draftJs.EditorState.push(editorState, contentStateWithBlock, 'insert-' + type);\n  return _draftJs.EditorState.forceSelection(newState, contentStateWithBlock.getSelectionAfter());\n};\n\nvar _immutable = require('immutable');\n\nvar _draftJs = require('draft-js');"]},"metadata":{},"sourceType":"script"}