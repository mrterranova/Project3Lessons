{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _draftJs = require('draft-js');\n\nvar _insertNewLine = require('./modifiers/insertNewLine');\n\nvar _insertNewLine2 = _interopRequireDefault(_insertNewLine);\n\nvar _setSelection = require('./modifiers/setSelection');\n\nvar _setSelection2 = _interopRequireDefault(_setSelection);\n\nvar _setSelectionToBlock = require('./modifiers/setSelectionToBlock');\n\nvar _setSelectionToBlock2 = _interopRequireDefault(_setSelectionToBlock);\n\nvar _createDecorator = require('./createDecorator');\n\nvar _createDecorator2 = _interopRequireDefault(_createDecorator);\n\nvar _createBlockKeyStore = require('./utils/createBlockKeyStore');\n\nvar _createBlockKeyStore2 = _interopRequireDefault(_createBlockKeyStore);\n\nvar _blockInSelection = require('./utils/blockInSelection');\n\nvar _blockInSelection2 = _interopRequireDefault(_blockInSelection);\n\nvar _getBlockMapKeys = require('./utils/getBlockMapKeys');\n\nvar _getBlockMapKeys2 = _interopRequireDefault(_getBlockMapKeys);\n\nvar _removeBlock = require('./modifiers/removeBlock');\n\nvar _removeBlock2 = _interopRequireDefault(_removeBlock);\n\nvar _style = {\n  \"unfocused\": \"draftJsFocusPlugin__unfocused__1Wvrs\",\n  \"focused\": \"draftJsFocusPlugin__focused__3Mksn\"\n};\n\nvar _style2 = _interopRequireDefault(_style);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar focusableBlockIsSelected = function focusableBlockIsSelected(editorState, blockKeyStore) {\n  var selection = editorState.getSelection();\n\n  if (selection.getAnchorKey() !== selection.getFocusKey()) {\n    return false;\n  }\n\n  var content = editorState.getCurrentContent();\n  var block = content.getBlockForKey(selection.getAnchorKey());\n  return blockKeyStore.includes(block.getKey());\n};\n\nvar deleteCommands = ['backspace', 'backspace-word', 'backspace-to-start-of-line', 'delete', 'delete-word', 'delete-to-end-of-block'];\n\nexports.default = function () {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var blockKeyStore = (0, _createBlockKeyStore2.default)({});\n  var theme = config.theme ? config.theme : _style2.default;\n  var lastSelection = void 0;\n  var lastContentState = void 0;\n  return {\n    handleReturn: function handleReturn(event, editorState, _ref) {\n      var setEditorState = _ref.setEditorState; // if a focusable block is selected then overwrite new line behavior to custom\n\n      if (focusableBlockIsSelected(editorState, blockKeyStore)) {\n        setEditorState((0, _insertNewLine2.default)(editorState));\n        return 'handled';\n      }\n\n      return 'not-handled';\n    },\n    handleKeyCommand: function handleKeyCommand(command, editorState, eventTimeStamp, _ref2) {\n      var setEditorState = _ref2.setEditorState;\n\n      if (deleteCommands.includes(command) && focusableBlockIsSelected(editorState, blockKeyStore)) {\n        var key = editorState.getSelection().getStartKey();\n        var newEditorState = (0, _removeBlock2.default)(editorState, key);\n\n        if (newEditorState !== editorState) {\n          setEditorState(newEditorState);\n          return 'handled';\n        }\n      }\n\n      return 'not-handled';\n    },\n    onChange: function onChange(editorState) {\n      // in case the content changed there is no need to re-render blockRendererFn\n      // since if a block was added it will be rendered anyway and if it was text\n      // then the change was not a pure selection change\n      var contentState = editorState.getCurrentContent();\n\n      if (!contentState.equals(lastContentState)) {\n        lastContentState = contentState;\n        return editorState;\n      }\n\n      lastContentState = contentState; // if the selection didn't change there is no need to re-render\n\n      var selection = editorState.getSelection();\n\n      if (lastSelection && selection.equals(lastSelection)) {\n        lastSelection = editorState.getSelection();\n        return editorState;\n      } // Note: Only if the previous or current selection contained a focusableBlock a re-render is needed.\n\n\n      var focusableBlockKeys = blockKeyStore.getAll();\n\n      if (lastSelection) {\n        var lastBlockMapKeys = (0, _getBlockMapKeys2.default)(contentState, lastSelection.getStartKey(), lastSelection.getEndKey());\n\n        if (lastBlockMapKeys.some(function (key) {\n          return focusableBlockKeys.includes(key);\n        })) {\n          lastSelection = selection; // By forcing the selection the editor will trigger the blockRendererFn which is\n          // necessary for the blockProps containing isFocus to be passed down again.\n\n          return _draftJs.EditorState.forceSelection(editorState, editorState.getSelection());\n        }\n      }\n\n      var currentBlockMapKeys = (0, _getBlockMapKeys2.default)(contentState, selection.getStartKey(), selection.getEndKey());\n\n      if (currentBlockMapKeys.some(function (key) {\n        return focusableBlockKeys.includes(key);\n      })) {\n        lastSelection = selection; // By forcing the selection the editor will trigger the blockRendererFn which is\n        // necessary for the blockProps containing isFocus to be passed down again.\n\n        return _draftJs.EditorState.forceSelection(editorState, editorState.getSelection());\n      }\n\n      return editorState;\n    },\n    // TODO edgecase: if one block is selected and the user wants to expand the selection using the shift key\n    keyBindingFn: function keyBindingFn(evt, _ref3) {\n      var getEditorState = _ref3.getEditorState,\n          setEditorState = _ref3.setEditorState;\n      var editorState = getEditorState(); // TODO match by entitiy instead of block type\n\n      if (focusableBlockIsSelected(editorState, blockKeyStore)) {\n        // arrow left\n        if (evt.keyCode === 37) {\n          (0, _setSelection2.default)(getEditorState, setEditorState, 'up', evt);\n        } // arrow right\n\n\n        if (evt.keyCode === 39) {\n          (0, _setSelection2.default)(getEditorState, setEditorState, 'down', evt);\n        } // arrow up\n\n\n        if (evt.keyCode === 38) {\n          (0, _setSelection2.default)(getEditorState, setEditorState, 'up', event);\n        } // arrow down\n\n\n        if (evt.keyCode === 40) {\n          (0, _setSelection2.default)(getEditorState, setEditorState, 'down', event);\n          return;\n        }\n      } // Don't manually overwrite in case the shift key is used to avoid breaking\n      // native behaviour that works anyway.\n\n\n      if (evt.shiftKey) {\n        return;\n      } // arrow left\n\n\n      if (evt.keyCode === 37) {\n        // Covering the case to select the before block\n        var selection = editorState.getSelection();\n        var selectionKey = selection.getAnchorKey();\n        var beforeBlock = editorState.getCurrentContent().getBlockBefore(selectionKey); // only if the selection caret is a the left most position\n\n        if (beforeBlock && selection.getAnchorOffset() === 0 && blockKeyStore.includes(beforeBlock.getKey())) {\n          (0, _setSelection2.default)(getEditorState, setEditorState, 'up', evt);\n        }\n      } // arrow right\n\n\n      if (evt.keyCode === 39) {\n        // Covering the case to select the after block\n        var _selection = editorState.getSelection();\n\n        var _selectionKey = _selection.getFocusKey();\n\n        var currentBlock = editorState.getCurrentContent().getBlockForKey(_selectionKey);\n        var afterBlock = editorState.getCurrentContent().getBlockAfter(_selectionKey);\n\n        var notAtomicAndLastPost = currentBlock.getType() !== 'atomic' && currentBlock.getLength() === _selection.getFocusOffset();\n\n        if (afterBlock && notAtomicAndLastPost && blockKeyStore.includes(afterBlock.getKey())) {\n          (0, _setSelection2.default)(getEditorState, setEditorState, 'down', evt);\n        }\n      } // arrow up\n\n\n      if (evt.keyCode === 38) {\n        // Covering the case to select the before block with arrow up\n        var _selectionKey2 = editorState.getSelection().getAnchorKey();\n\n        var _beforeBlock = editorState.getCurrentContent().getBlockBefore(_selectionKey2);\n\n        if (_beforeBlock && blockKeyStore.includes(_beforeBlock.getKey())) {\n          (0, _setSelection2.default)(getEditorState, setEditorState, 'up', event);\n        }\n      } // arrow down\n\n\n      if (evt.keyCode === 40) {\n        // Covering the case to select the after block with arrow down\n        var _selectionKey3 = editorState.getSelection().getAnchorKey();\n\n        var _afterBlock = editorState.getCurrentContent().getBlockAfter(_selectionKey3);\n\n        if (_afterBlock && blockKeyStore.includes(_afterBlock.getKey())) {\n          (0, _setSelection2.default)(getEditorState, setEditorState, 'down', event);\n        }\n      }\n    },\n    // Wrap all block-types in block-focus decorator\n    blockRendererFn: function blockRendererFn(contentBlock, _ref4) {\n      var getEditorState = _ref4.getEditorState,\n          setEditorState = _ref4.setEditorState; // This makes it mandatory to have atomic blocks for focus but also improves performance\n      // since all the selection checks are not necessary.\n      // In case there is a use-case where focus makes sense for none atomic blocks we can add it\n      // in the future.\n\n      if (contentBlock.getType() !== 'atomic') {\n        return undefined;\n      }\n\n      var editorState = getEditorState();\n      var isFocused = (0, _blockInSelection2.default)(editorState, contentBlock.getKey());\n      return {\n        props: {\n          isFocused: isFocused,\n          isCollapsedSelection: editorState.getSelection().isCollapsed(),\n          setFocusToBlock: function setFocusToBlock() {\n            (0, _setSelectionToBlock2.default)(getEditorState, setEditorState, contentBlock);\n          }\n        }\n      };\n    },\n    decorator: (0, _createDecorator2.default)({\n      theme: theme,\n      blockKeyStore: blockKeyStore\n    })\n  };\n};","map":{"version":3,"sources":["C:/Users/User/Desktop/MERN Passport/client/node_modules/draft-js-focus-plugin/lib/index.js"],"names":["Object","defineProperty","exports","value","_draftJs","require","_insertNewLine","_insertNewLine2","_interopRequireDefault","_setSelection","_setSelection2","_setSelectionToBlock","_setSelectionToBlock2","_createDecorator","_createDecorator2","_createBlockKeyStore","_createBlockKeyStore2","_blockInSelection","_blockInSelection2","_getBlockMapKeys","_getBlockMapKeys2","_removeBlock","_removeBlock2","_style","_style2","obj","__esModule","default","focusableBlockIsSelected","editorState","blockKeyStore","selection","getSelection","getAnchorKey","getFocusKey","content","getCurrentContent","block","getBlockForKey","includes","getKey","deleteCommands","config","arguments","length","undefined","theme","lastSelection","lastContentState","handleReturn","event","_ref","setEditorState","handleKeyCommand","command","eventTimeStamp","_ref2","key","getStartKey","newEditorState","onChange","contentState","equals","focusableBlockKeys","getAll","lastBlockMapKeys","getEndKey","some","EditorState","forceSelection","currentBlockMapKeys","keyBindingFn","evt","_ref3","getEditorState","keyCode","shiftKey","selectionKey","beforeBlock","getBlockBefore","getAnchorOffset","_selection","_selectionKey","currentBlock","afterBlock","getBlockAfter","notAtomicAndLastPost","getType","getLength","getFocusOffset","_selectionKey2","_beforeBlock","_selectionKey3","_afterBlock","blockRendererFn","contentBlock","_ref4","isFocused","props","isCollapsedSelection","isCollapsed","setFocusToBlock","decorator"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _draftJs = require('draft-js');\n\nvar _insertNewLine = require('./modifiers/insertNewLine');\n\nvar _insertNewLine2 = _interopRequireDefault(_insertNewLine);\n\nvar _setSelection = require('./modifiers/setSelection');\n\nvar _setSelection2 = _interopRequireDefault(_setSelection);\n\nvar _setSelectionToBlock = require('./modifiers/setSelectionToBlock');\n\nvar _setSelectionToBlock2 = _interopRequireDefault(_setSelectionToBlock);\n\nvar _createDecorator = require('./createDecorator');\n\nvar _createDecorator2 = _interopRequireDefault(_createDecorator);\n\nvar _createBlockKeyStore = require('./utils/createBlockKeyStore');\n\nvar _createBlockKeyStore2 = _interopRequireDefault(_createBlockKeyStore);\n\nvar _blockInSelection = require('./utils/blockInSelection');\n\nvar _blockInSelection2 = _interopRequireDefault(_blockInSelection);\n\nvar _getBlockMapKeys = require('./utils/getBlockMapKeys');\n\nvar _getBlockMapKeys2 = _interopRequireDefault(_getBlockMapKeys);\n\nvar _removeBlock = require('./modifiers/removeBlock');\n\nvar _removeBlock2 = _interopRequireDefault(_removeBlock);\n\nvar _style = {\n  \"unfocused\": \"draftJsFocusPlugin__unfocused__1Wvrs\",\n  \"focused\": \"draftJsFocusPlugin__focused__3Mksn\"\n};\n\nvar _style2 = _interopRequireDefault(_style);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar focusableBlockIsSelected = function focusableBlockIsSelected(editorState, blockKeyStore) {\n  var selection = editorState.getSelection();\n  if (selection.getAnchorKey() !== selection.getFocusKey()) {\n    return false;\n  }\n  var content = editorState.getCurrentContent();\n  var block = content.getBlockForKey(selection.getAnchorKey());\n  return blockKeyStore.includes(block.getKey());\n};\n\nvar deleteCommands = ['backspace', 'backspace-word', 'backspace-to-start-of-line', 'delete', 'delete-word', 'delete-to-end-of-block'];\n\nexports.default = function () {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var blockKeyStore = (0, _createBlockKeyStore2.default)({});\n  var theme = config.theme ? config.theme : _style2.default;\n  var lastSelection = void 0;\n  var lastContentState = void 0;\n\n  return {\n    handleReturn: function handleReturn(event, editorState, _ref) {\n      var setEditorState = _ref.setEditorState;\n\n      // if a focusable block is selected then overwrite new line behavior to custom\n      if (focusableBlockIsSelected(editorState, blockKeyStore)) {\n        setEditorState((0, _insertNewLine2.default)(editorState));\n        return 'handled';\n      }\n      return 'not-handled';\n    },\n\n    handleKeyCommand: function handleKeyCommand(command, editorState, eventTimeStamp, _ref2) {\n      var setEditorState = _ref2.setEditorState;\n\n      if (deleteCommands.includes(command) && focusableBlockIsSelected(editorState, blockKeyStore)) {\n        var key = editorState.getSelection().getStartKey();\n        var newEditorState = (0, _removeBlock2.default)(editorState, key);\n        if (newEditorState !== editorState) {\n          setEditorState(newEditorState);\n          return 'handled';\n        }\n      }\n      return 'not-handled';\n    },\n\n    onChange: function onChange(editorState) {\n      // in case the content changed there is no need to re-render blockRendererFn\n      // since if a block was added it will be rendered anyway and if it was text\n      // then the change was not a pure selection change\n      var contentState = editorState.getCurrentContent();\n      if (!contentState.equals(lastContentState)) {\n        lastContentState = contentState;\n        return editorState;\n      }\n      lastContentState = contentState;\n\n      // if the selection didn't change there is no need to re-render\n      var selection = editorState.getSelection();\n      if (lastSelection && selection.equals(lastSelection)) {\n        lastSelection = editorState.getSelection();\n        return editorState;\n      }\n\n      // Note: Only if the previous or current selection contained a focusableBlock a re-render is needed.\n      var focusableBlockKeys = blockKeyStore.getAll();\n      if (lastSelection) {\n        var lastBlockMapKeys = (0, _getBlockMapKeys2.default)(contentState, lastSelection.getStartKey(), lastSelection.getEndKey());\n        if (lastBlockMapKeys.some(function (key) {\n          return focusableBlockKeys.includes(key);\n        })) {\n          lastSelection = selection;\n          // By forcing the selection the editor will trigger the blockRendererFn which is\n          // necessary for the blockProps containing isFocus to be passed down again.\n          return _draftJs.EditorState.forceSelection(editorState, editorState.getSelection());\n        }\n      }\n\n      var currentBlockMapKeys = (0, _getBlockMapKeys2.default)(contentState, selection.getStartKey(), selection.getEndKey());\n      if (currentBlockMapKeys.some(function (key) {\n        return focusableBlockKeys.includes(key);\n      })) {\n        lastSelection = selection;\n        // By forcing the selection the editor will trigger the blockRendererFn which is\n        // necessary for the blockProps containing isFocus to be passed down again.\n        return _draftJs.EditorState.forceSelection(editorState, editorState.getSelection());\n      }\n\n      return editorState;\n    },\n\n    // TODO edgecase: if one block is selected and the user wants to expand the selection using the shift key\n    keyBindingFn: function keyBindingFn(evt, _ref3) {\n      var getEditorState = _ref3.getEditorState,\n          setEditorState = _ref3.setEditorState;\n\n      var editorState = getEditorState();\n      // TODO match by entitiy instead of block type\n      if (focusableBlockIsSelected(editorState, blockKeyStore)) {\n        // arrow left\n        if (evt.keyCode === 37) {\n          (0, _setSelection2.default)(getEditorState, setEditorState, 'up', evt);\n        }\n        // arrow right\n        if (evt.keyCode === 39) {\n          (0, _setSelection2.default)(getEditorState, setEditorState, 'down', evt);\n        }\n        // arrow up\n        if (evt.keyCode === 38) {\n          (0, _setSelection2.default)(getEditorState, setEditorState, 'up', event);\n        }\n        // arrow down\n        if (evt.keyCode === 40) {\n          (0, _setSelection2.default)(getEditorState, setEditorState, 'down', event);\n          return;\n        }\n      }\n\n      // Don't manually overwrite in case the shift key is used to avoid breaking\n      // native behaviour that works anyway.\n      if (evt.shiftKey) {\n        return;\n      }\n\n      // arrow left\n      if (evt.keyCode === 37) {\n        // Covering the case to select the before block\n        var selection = editorState.getSelection();\n        var selectionKey = selection.getAnchorKey();\n        var beforeBlock = editorState.getCurrentContent().getBlockBefore(selectionKey);\n        // only if the selection caret is a the left most position\n        if (beforeBlock && selection.getAnchorOffset() === 0 && blockKeyStore.includes(beforeBlock.getKey())) {\n          (0, _setSelection2.default)(getEditorState, setEditorState, 'up', evt);\n        }\n      }\n\n      // arrow right\n      if (evt.keyCode === 39) {\n        // Covering the case to select the after block\n        var _selection = editorState.getSelection();\n        var _selectionKey = _selection.getFocusKey();\n        var currentBlock = editorState.getCurrentContent().getBlockForKey(_selectionKey);\n        var afterBlock = editorState.getCurrentContent().getBlockAfter(_selectionKey);\n        var notAtomicAndLastPost = currentBlock.getType() !== 'atomic' && currentBlock.getLength() === _selection.getFocusOffset();\n        if (afterBlock && notAtomicAndLastPost && blockKeyStore.includes(afterBlock.getKey())) {\n          (0, _setSelection2.default)(getEditorState, setEditorState, 'down', evt);\n        }\n      }\n\n      // arrow up\n      if (evt.keyCode === 38) {\n        // Covering the case to select the before block with arrow up\n        var _selectionKey2 = editorState.getSelection().getAnchorKey();\n        var _beforeBlock = editorState.getCurrentContent().getBlockBefore(_selectionKey2);\n        if (_beforeBlock && blockKeyStore.includes(_beforeBlock.getKey())) {\n          (0, _setSelection2.default)(getEditorState, setEditorState, 'up', event);\n        }\n      }\n\n      // arrow down\n      if (evt.keyCode === 40) {\n        // Covering the case to select the after block with arrow down\n        var _selectionKey3 = editorState.getSelection().getAnchorKey();\n        var _afterBlock = editorState.getCurrentContent().getBlockAfter(_selectionKey3);\n        if (_afterBlock && blockKeyStore.includes(_afterBlock.getKey())) {\n          (0, _setSelection2.default)(getEditorState, setEditorState, 'down', event);\n        }\n      }\n    },\n\n\n    // Wrap all block-types in block-focus decorator\n    blockRendererFn: function blockRendererFn(contentBlock, _ref4) {\n      var getEditorState = _ref4.getEditorState,\n          setEditorState = _ref4.setEditorState;\n\n      // This makes it mandatory to have atomic blocks for focus but also improves performance\n      // since all the selection checks are not necessary.\n      // In case there is a use-case where focus makes sense for none atomic blocks we can add it\n      // in the future.\n      if (contentBlock.getType() !== 'atomic') {\n        return undefined;\n      }\n\n      var editorState = getEditorState();\n      var isFocused = (0, _blockInSelection2.default)(editorState, contentBlock.getKey());\n\n      return {\n        props: {\n          isFocused: isFocused,\n          isCollapsedSelection: editorState.getSelection().isCollapsed(),\n          setFocusToBlock: function setFocusToBlock() {\n            (0, _setSelectionToBlock2.default)(getEditorState, setEditorState, contentBlock);\n          }\n        }\n      };\n    },\n\n    decorator: (0, _createDecorator2.default)({ theme: theme, blockKeyStore: blockKeyStore })\n  };\n};"]},"metadata":{},"sourceType":"script"}