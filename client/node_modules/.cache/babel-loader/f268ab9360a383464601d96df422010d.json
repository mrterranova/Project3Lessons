{"ast":null,"code":"import _slicedToArray from \"C:\\\\Users\\\\User\\\\Desktop\\\\MERN Passport\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport ReactDOM from 'react-dom';\nimport { matchesSelectorAndParentsTo, addEvent, removeEvent, addUserSelectStyles, getTouchIdentifier, removeUserSelectStyles, styleHacks } from './utils/domFns';\nimport { createCoreData, getControlPosition, snapToGrid } from './utils/positionFns';\nimport { dontSetMe } from './utils/shims';\nimport log from './utils/log';\n// Simple abstraction for dragging events names.\nconst eventsFor = {\n  touch: {\n    start: 'touchstart',\n    move: 'touchmove',\n    stop: 'touchend'\n  },\n  mouse: {\n    start: 'mousedown',\n    move: 'mousemove',\n    stop: 'mouseup'\n  }\n}; // Default to mouse events.\n\nlet dragEventFor = eventsFor.mouse;\n//\n// Define <DraggableCore>.\n//\n// <DraggableCore> is for advanced usage of <Draggable>. It maintains minimal internal state so it can\n// work well with libraries that require more control over the element.\n//\nexport default class UserLesson extends React.Component {\n  constructor(...args) {\n    super(...args);\n    this.state = {\n      dragging: false,\n      // Used while dragging to determine deltas.\n      lastX: NaN,\n      lastY: NaN,\n      touchIdentifier: null\n    };\n\n    this.handleDragStart = e => {\n      // Make it possible to attach event handlers on top of this one.\n      this.props.onMouseDown(e); // Only accept left-clicks.\n\n      if (!this.props.allowAnyClick && typeof e.button === 'number' && e.button !== 0) return false; // Get nodes. Be sure to grab relative document (could be iframed)\n\n      const thisNode = ReactDOM.findDOMNode(this);\n\n      if (!thisNode || !thisNode.ownerDocument || !thisNode.ownerDocument.body) {\n        throw new Error('<DraggableCore> not mounted on DragStart!');\n      }\n\n      const ownerDocument = thisNode.ownerDocument; // Short circuit if handle or cancel prop was provided and selector doesn't match.\n\n      if (this.props.disabled || !(e.target instanceof ownerDocument.defaultView.Node) || this.props.handle && !matchesSelectorAndParentsTo(e.target, this.props.handle, thisNode) || this.props.cancel && matchesSelectorAndParentsTo(e.target, this.props.cancel, thisNode)) {\n        return;\n      } // Set touch identifier in component state if this is a touch event. This allows us to\n      // distinguish between individual touches on multitouch screens by identifying which\n      // touchpoint was set to this element.\n\n\n      const touchIdentifier = getTouchIdentifier(e);\n      this.setState({\n        touchIdentifier\n      }); // Get the current drag point from the event. This is used as the offset.\n\n      const position = getControlPosition(e, touchIdentifier, this);\n      if (position == null) return; // not possible but satisfies flow\n\n      const x = position.x,\n            y = position.y; // Create an event object with all the data parents need to make a decision here.\n\n      const coreEvent = createCoreData(this, x, y);\n      log('DraggableCore: handleDragStart: %j', coreEvent); // Call event handler. If it returns explicit false, cancel.\n\n      log('calling', this.props.onStart);\n      const shouldUpdate = this.props.onStart(e, coreEvent);\n      if (shouldUpdate === false) return; // Add a style to the body to disable user-select. This prevents text from\n      // being selected all over the page.\n\n      if (this.props.enableUserSelectHack) addUserSelectStyles(ownerDocument); // Initiate dragging. Set the current x and y as offsets\n      // so we know how much we've moved during the drag. This allows us\n      // to drag elements around even if they have been moved, without issue.\n\n      this.setState({\n        dragging: true,\n        lastX: x,\n        lastY: y\n      }); // Add events to the document directly so we catch when the user's mouse/touch moves outside of\n      // this element. We use different events depending on whether or not we have detected that this\n      // is a touch-capable device.\n\n      addEvent(ownerDocument, dragEventFor.move, this.handleDrag);\n      addEvent(ownerDocument, dragEventFor.stop, this.handleDragStop);\n    };\n\n    this.handleDrag = e => {\n      // Prevent scrolling on mobile devices, like ipad/iphone.\n      if (e.type === 'touchmove') e.preventDefault(); // Get the current drag point from the event. This is used as the offset.\n\n      const position = getControlPosition(e, this.state.touchIdentifier, this);\n      if (position == null) return;\n      let x = position.x,\n          y = position.y; // Snap to grid if prop has been provided\n\n      if (Array.isArray(this.props.grid)) {\n        let deltaX = x - this.state.lastX,\n            deltaY = y - this.state.lastY;\n\n        var _snapToGrid = snapToGrid(this.props.grid, deltaX, deltaY);\n\n        var _snapToGrid2 = _slicedToArray(_snapToGrid, 2);\n\n        deltaX = _snapToGrid2[0];\n        deltaY = _snapToGrid2[1];\n        if (!deltaX && !deltaY) return; // skip useless drag\n\n        x = this.state.lastX + deltaX, y = this.state.lastY + deltaY;\n      }\n\n      const coreEvent = createCoreData(this, x, y);\n      log('DraggableCore: handleDrag: %j', coreEvent); // Call event handler. If it returns explicit false, trigger end.\n\n      const shouldUpdate = this.props.onDrag(e, coreEvent);\n\n      if (shouldUpdate === false) {\n        try {\n          // $FlowIgnore\n          this.handleDragStop(new MouseEvent('mouseup'));\n        } catch (err) {\n          // Old browsers\n          const event = document.createEvent('MouseEvents'); // I see why this insanity was deprecated\n          // $FlowIgnore\n\n          event.initMouseEvent('mouseup', true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n          this.handleDragStop(event);\n        }\n\n        return;\n      }\n\n      this.setState({\n        lastX: x,\n        lastY: y\n      });\n    };\n\n    this.handleDragStop = e => {\n      if (!this.state.dragging) return;\n      const position = getControlPosition(e, this.state.touchIdentifier, this);\n      if (position == null) return;\n      const x = position.x,\n            y = position.y;\n      const coreEvent = createCoreData(this, x, y);\n      const thisNode = ReactDOM.findDOMNode(this);\n\n      if (thisNode) {\n        // Remove user-select hack\n        if (this.props.enableUserSelectHack) removeUserSelectStyles(thisNode.ownerDocument);\n      }\n\n      log('DraggableCore: handleDragStop: %j', coreEvent); // Reset the el.\n\n      this.setState({\n        dragging: false,\n        lastX: NaN,\n        lastY: NaN\n      }); // Call event handler\n\n      this.props.onStop(e, coreEvent);\n\n      if (thisNode) {\n        // Remove event handlers\n        log('DraggableCore: Removing handlers');\n        removeEvent(thisNode.ownerDocument, dragEventFor.move, this.handleDrag);\n        removeEvent(thisNode.ownerDocument, dragEventFor.stop, this.handleDragStop);\n      }\n    };\n\n    this.onMouseDown = e => {\n      dragEventFor = eventsFor.mouse; // on touchscreen laptops we could switch back to mouse\n\n      return this.handleDragStart(e);\n    };\n\n    this.onMouseUp = e => {\n      dragEventFor = eventsFor.mouse;\n      return this.handleDragStop(e);\n    };\n\n    this.onTouchStart = e => {\n      // We're on a touch device now, so change the event handlers\n      dragEventFor = eventsFor.touch;\n      return this.handleDragStart(e);\n    };\n\n    this.onTouchEnd = e => {\n      // We're on a touch device now, so change the event handlers\n      dragEventFor = eventsFor.touch;\n      return this.handleDragStop(e);\n    };\n  }\n\n  componentWillUnmount() {\n    // Remove any leftover event handlers. Remove both touch and mouse handlers in case\n    // some browser quirk caused a touch event to fire during a mouse move, or vice versa.\n    const thisNode = ReactDOM.findDOMNode(this);\n\n    if (thisNode) {\n      const ownerDocument = thisNode.ownerDocument;\n      removeEvent(ownerDocument, eventsFor.mouse.move, this.handleDrag);\n      removeEvent(ownerDocument, eventsFor.touch.move, this.handleDrag);\n      removeEvent(ownerDocument, eventsFor.mouse.stop, this.handleDragStop);\n      removeEvent(ownerDocument, eventsFor.touch.stop, this.handleDragStop);\n      if (this.props.enableUserSelectHack) removeUserSelectStyles(ownerDocument);\n    }\n  }\n\n  render() {\n    // Reuse the child provided\n    // This makes it flexible to use whatever element is wanted (div, ul, etc)\n    return React.cloneElement(React.Children.only(this.props.children), {\n      style: styleHacks(this.props.children.props.style),\n      // Note: mouseMove handler is attached to document so it will still function\n      // when the user drags quickly and leaves the bounds of the element.\n      onMouseDown: this.onMouseDown,\n      onTouchStart: this.onTouchStart,\n      onMouseUp: this.onMouseUp,\n      onTouchEnd: this.onTouchEnd\n    });\n  }\n\n}\nUserLesson.displayName = 'DraggableCore';\nUserLesson.propTypes = {\n  /**\r\n   * `allowAnyClick` allows dragging using any mouse button.\r\n   * By default, we only accept the left button.\r\n   *\r\n   * Defaults to `false`.\r\n   */\n  allowAnyClick: PropTypes.bool,\n\n  /**\r\n   * `disabled`, if true, stops the <Draggable> from dragging. All handlers,\r\n   * with the exception of `onMouseDown`, will not fire.\r\n   */\n  disabled: PropTypes.bool,\n\n  /**\r\n   * By default, we add 'user-select:none' attributes to the document body\r\n   * to prevent ugly text selection during drag. If this is causing problems\r\n   * for your app, set this to `false`.\r\n   */\n  enableUserSelectHack: PropTypes.bool,\n\n  /**\r\n   * `offsetParent`, if set, uses the passed DOM node to compute drag offsets\r\n   * instead of using the parent node.\r\n   */\n  offsetParent: function (props, propName) {\n    if (props[propName] && props[propName].nodeType !== 1) {\n      throw new Error('Draggable\\'s offsetParent must be a DOM Node.');\n    }\n  },\n\n  /**\r\n   * `grid` specifies the x and y that dragging should snap to.\r\n   */\n  grid: PropTypes.arrayOf(PropTypes.number),\n\n  /**\r\n   * `handle` specifies a selector to be used as the handle that initiates drag.\r\n   *\r\n   * Example:\r\n   *\r\n   * ```jsx\r\n   *   let App = React.createClass({\r\n   *       render: function () {\r\n   *         return (\r\n   *            <Draggable handle=\".handle\">\r\n   *              <div>\r\n   *                  <div className=\"handle\">Click me to drag</div>\r\n   *                  <div>This is some other content</div>\r\n   *              </div>\r\n   *           </Draggable>\r\n   *         );\r\n   *       }\r\n   *   });\r\n   * ```\r\n   */\n  handle: PropTypes.string,\n\n  /**\r\n   * `cancel` specifies a selector to be used to prevent drag initialization.\r\n   *\r\n   * Example:\r\n   *\r\n   * ```jsx\r\n   *   let App = React.createClass({\r\n   *       render: function () {\r\n   *           return(\r\n   *               <Draggable cancel=\".cancel\">\r\n   *                   <div>\r\n   *                     <div className=\"cancel\">You can't drag from here</div>\r\n   *                     <div>Dragging here works fine</div>\r\n   *                   </div>\r\n   *               </Draggable>\r\n   *           );\r\n   *       }\r\n   *   });\r\n   * ```\r\n   */\n  cancel: PropTypes.string,\n\n  /**\r\n   * Called when dragging starts.\r\n   * If this function returns the boolean false, dragging will be canceled.\r\n   */\n  onStart: PropTypes.func,\n\n  /**\r\n   * Called while dragging.\r\n   * If this function returns the boolean false, dragging will be canceled.\r\n   */\n  onDrag: PropTypes.func,\n\n  /**\r\n   * Called when dragging stops.\r\n   * If this function returns the boolean false, the drag will remain active.\r\n   */\n  onStop: PropTypes.func,\n\n  /**\r\n   * A workaround option which can be passed if onMouseDown needs to be accessed,\r\n   * since it'll always be blocked (as there is internal use of onMouseDown)\r\n   */\n  onMouseDown: PropTypes.func,\n\n  /**\r\n   * `scale`, if set, applies scaling while dragging an element\r\n   */\n  scale: PropTypes.number,\n\n  /**\r\n   * These properties should be defined on the child, not here.\r\n   */\n  className: dontSetMe,\n  style: dontSetMe,\n  transform: dontSetMe\n};\nUserLesson.defaultProps = {\n  allowAnyClick: false,\n  // by default only accept left click\n  cancel: null,\n  disabled: false,\n  enableUserSelectHack: true,\n  offsetParent: null,\n  handle: null,\n  grid: null,\n  transform: null,\n  onStart: function () {},\n  onDrag: function () {},\n  onStop: function () {},\n  onMouseDown: function () {},\n  scale: 1\n};","map":{"version":3,"sources":["C:/Users/User/Desktop/MERN Passport/client/src/core/pages/Lesson/UserLesson.js"],"names":["React","PropTypes","ReactDOM","matchesSelectorAndParentsTo","addEvent","removeEvent","addUserSelectStyles","getTouchIdentifier","removeUserSelectStyles","styleHacks","createCoreData","getControlPosition","snapToGrid","dontSetMe","log","eventsFor","touch","start","move","stop","mouse","dragEventFor","UserLesson","Component","state","dragging","lastX","NaN","lastY","touchIdentifier","handleDragStart","e","props","onMouseDown","allowAnyClick","button","thisNode","findDOMNode","ownerDocument","body","Error","disabled","target","defaultView","Node","handle","cancel","setState","position","x","y","coreEvent","onStart","shouldUpdate","enableUserSelectHack","handleDrag","handleDragStop","type","preventDefault","Array","isArray","grid","deltaX","deltaY","onDrag","MouseEvent","err","event","document","createEvent","initMouseEvent","window","onStop","onMouseUp","onTouchStart","onTouchEnd","componentWillUnmount","render","cloneElement","Children","only","children","style","displayName","propTypes","bool","offsetParent","propName","nodeType","arrayOf","number","string","func","scale","className","transform","defaultProps"],"mappings":"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","sourcesContent":["// @flow\r\nimport React from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport ReactDOM from 'react-dom';\r\nimport {matchesSelectorAndParentsTo, addEvent, removeEvent, addUserSelectStyles, getTouchIdentifier,\r\n        removeUserSelectStyles, styleHacks} from './utils/domFns';\r\nimport {createCoreData, getControlPosition, snapToGrid} from './utils/positionFns';\r\nimport {dontSetMe} from './utils/shims';\r\nimport log from './utils/log';\r\n\r\nimport type {EventHandler, MouseTouchEvent} from './utils/types';\r\nimport type {Element as ReactElement} from 'react';\r\n\r\n// Simple abstraction for dragging events names.\r\nconst eventsFor = {\r\n  touch: {\r\n    start: 'touchstart',\r\n    move: 'touchmove',\r\n    stop: 'touchend'\r\n  },\r\n  mouse: {\r\n    start: 'mousedown',\r\n    move: 'mousemove',\r\n    stop: 'mouseup'\r\n  }\r\n};\r\n\r\n// Default to mouse events.\r\nlet dragEventFor = eventsFor.mouse;\r\n\r\ntype DraggableCoreState = {\r\n  dragging: boolean,\r\n  lastX: number,\r\n  lastY: number,\r\n  touchIdentifier: ?number\r\n};\r\n\r\nexport type DraggableBounds = {\r\n  left: number,\r\n  right: number,\r\n  top: number,\r\n  bottom: number,\r\n};\r\n\r\nexport type DraggableData = {\r\n  node: HTMLElement,\r\n  x: number, y: number,\r\n  deltaX: number, deltaY: number,\r\n  lastX: number, lastY: number,\r\n};\r\n\r\nexport type DraggableEventHandler = (e: MouseEvent, data: DraggableData) => void;\r\n\r\nexport type ControlPosition = {x: number, y: number};\r\nexport type PositionOffsetControlPosition = {x: number|string, y: number|string};\r\n\r\nexport type DraggableCoreProps = {\r\n  allowAnyClick: boolean,\r\n  cancel: string,\r\n  children: ReactElement<any>,\r\n  disabled: boolean,\r\n  enableUserSelectHack: boolean,\r\n  offsetParent: HTMLElement,\r\n  grid: [number, number],\r\n  handle: string,\r\n  onStart: DraggableEventHandler,\r\n  onDrag: DraggableEventHandler,\r\n  onStop: DraggableEventHandler,\r\n  onMouseDown: (e: MouseEvent) => void,\r\n  scale: number,\r\n};\r\n\r\n//\r\n// Define <DraggableCore>.\r\n//\r\n// <DraggableCore> is for advanced usage of <Draggable>. It maintains minimal internal state so it can\r\n// work well with libraries that require more control over the element.\r\n//\r\n\r\nexport default class UserLesson extends React.Component<DraggableCoreProps, DraggableCoreState> {\r\n\r\n  static displayName = 'DraggableCore';\r\n\r\n  static propTypes = {\r\n    /**\r\n     * `allowAnyClick` allows dragging using any mouse button.\r\n     * By default, we only accept the left button.\r\n     *\r\n     * Defaults to `false`.\r\n     */\r\n    allowAnyClick: PropTypes.bool,\r\n\r\n    /**\r\n     * `disabled`, if true, stops the <Draggable> from dragging. All handlers,\r\n     * with the exception of `onMouseDown`, will not fire.\r\n     */\r\n    disabled: PropTypes.bool,\r\n\r\n    /**\r\n     * By default, we add 'user-select:none' attributes to the document body\r\n     * to prevent ugly text selection during drag. If this is causing problems\r\n     * for your app, set this to `false`.\r\n     */\r\n    enableUserSelectHack: PropTypes.bool,\r\n\r\n    /**\r\n     * `offsetParent`, if set, uses the passed DOM node to compute drag offsets\r\n     * instead of using the parent node.\r\n     */\r\n    offsetParent: function(props: DraggableCoreProps, propName: $Keys<DraggableCoreProps>) {\r\n      if (props[propName] && props[propName].nodeType !== 1) {\r\n        throw new Error('Draggable\\'s offsetParent must be a DOM Node.');\r\n      }\r\n    },\r\n\r\n    /**\r\n     * `grid` specifies the x and y that dragging should snap to.\r\n     */\r\n    grid: PropTypes.arrayOf(PropTypes.number),\r\n    \r\n    /**\r\n     * `handle` specifies a selector to be used as the handle that initiates drag.\r\n     *\r\n     * Example:\r\n     *\r\n     * ```jsx\r\n     *   let App = React.createClass({\r\n     *       render: function () {\r\n     *         return (\r\n     *            <Draggable handle=\".handle\">\r\n     *              <div>\r\n     *                  <div className=\"handle\">Click me to drag</div>\r\n     *                  <div>This is some other content</div>\r\n     *              </div>\r\n     *           </Draggable>\r\n     *         );\r\n     *       }\r\n     *   });\r\n     * ```\r\n     */\r\n    handle: PropTypes.string,\r\n\r\n    /**\r\n     * `cancel` specifies a selector to be used to prevent drag initialization.\r\n     *\r\n     * Example:\r\n     *\r\n     * ```jsx\r\n     *   let App = React.createClass({\r\n     *       render: function () {\r\n     *           return(\r\n     *               <Draggable cancel=\".cancel\">\r\n     *                   <div>\r\n     *                     <div className=\"cancel\">You can't drag from here</div>\r\n     *                     <div>Dragging here works fine</div>\r\n     *                   </div>\r\n     *               </Draggable>\r\n     *           );\r\n     *       }\r\n     *   });\r\n     * ```\r\n     */\r\n    cancel: PropTypes.string,\r\n\r\n    /**\r\n     * Called when dragging starts.\r\n     * If this function returns the boolean false, dragging will be canceled.\r\n     */\r\n    onStart: PropTypes.func,\r\n\r\n    /**\r\n     * Called while dragging.\r\n     * If this function returns the boolean false, dragging will be canceled.\r\n     */\r\n    onDrag: PropTypes.func,\r\n\r\n    /**\r\n     * Called when dragging stops.\r\n     * If this function returns the boolean false, the drag will remain active.\r\n     */\r\n    onStop: PropTypes.func,\r\n\r\n    /**\r\n     * A workaround option which can be passed if onMouseDown needs to be accessed,\r\n     * since it'll always be blocked (as there is internal use of onMouseDown)\r\n     */\r\n    onMouseDown: PropTypes.func,\r\n\r\n    /**\r\n     * `scale`, if set, applies scaling while dragging an element\r\n     */\r\n    scale: PropTypes.number,\r\n\r\n    /**\r\n     * These properties should be defined on the child, not here.\r\n     */\r\n    className: dontSetMe,\r\n    style: dontSetMe,\r\n    transform: dontSetMe\r\n  };\r\n\r\n  static defaultProps = {\r\n    allowAnyClick: false, // by default only accept left click\r\n    cancel: null,\r\n    disabled: false,\r\n    enableUserSelectHack: true,\r\n    offsetParent: null,\r\n    handle: null,\r\n    grid: null,\r\n    transform: null,\r\n    onStart: function(){},\r\n    onDrag: function(){},\r\n    onStop: function(){},\r\n    onMouseDown: function(){},\r\n    scale: 1,\r\n  };\r\n\r\n  state = {\r\n    dragging: false,\r\n    // Used while dragging to determine deltas.\r\n    lastX: NaN, lastY: NaN,\r\n    touchIdentifier: null\r\n  };\r\n\r\n  componentWillUnmount() {\r\n    // Remove any leftover event handlers. Remove both touch and mouse handlers in case\r\n    // some browser quirk caused a touch event to fire during a mouse move, or vice versa.\r\n    const thisNode = ReactDOM.findDOMNode(this);\r\n    if (thisNode) {\r\n      const {ownerDocument} = thisNode;\r\n      removeEvent(ownerDocument, eventsFor.mouse.move, this.handleDrag);\r\n      removeEvent(ownerDocument, eventsFor.touch.move, this.handleDrag);\r\n      removeEvent(ownerDocument, eventsFor.mouse.stop, this.handleDragStop);\r\n      removeEvent(ownerDocument, eventsFor.touch.stop, this.handleDragStop);\r\n      if (this.props.enableUserSelectHack) removeUserSelectStyles(ownerDocument);\r\n    }\r\n  }\r\n\r\n  handleDragStart: EventHandler<MouseTouchEvent> = (e) => {\r\n    // Make it possible to attach event handlers on top of this one.\r\n    this.props.onMouseDown(e);\r\n\r\n    // Only accept left-clicks.\r\n    if (!this.props.allowAnyClick && typeof e.button === 'number' && e.button !== 0) return false;\r\n\r\n    // Get nodes. Be sure to grab relative document (could be iframed)\r\n    const thisNode = ReactDOM.findDOMNode(this);\r\n    if (!thisNode || !thisNode.ownerDocument || !thisNode.ownerDocument.body) {\r\n      throw new Error('<DraggableCore> not mounted on DragStart!');\r\n    }\r\n    const {ownerDocument} = thisNode;\r\n\r\n    // Short circuit if handle or cancel prop was provided and selector doesn't match.\r\n    if (this.props.disabled ||\r\n      (!(e.target instanceof ownerDocument.defaultView.Node)) ||\r\n      (this.props.handle && !matchesSelectorAndParentsTo(e.target, this.props.handle, thisNode)) ||\r\n      (this.props.cancel && matchesSelectorAndParentsTo(e.target, this.props.cancel, thisNode))) {\r\n      return;\r\n    }\r\n\r\n    // Set touch identifier in component state if this is a touch event. This allows us to\r\n    // distinguish between individual touches on multitouch screens by identifying which\r\n    // touchpoint was set to this element.\r\n    const touchIdentifier = getTouchIdentifier(e);\r\n    this.setState({touchIdentifier});\r\n\r\n    // Get the current drag point from the event. This is used as the offset.\r\n    const position = getControlPosition(e, touchIdentifier, this);\r\n    if (position == null) return; // not possible but satisfies flow\r\n    const {x, y} = position;\r\n\r\n    // Create an event object with all the data parents need to make a decision here.\r\n    const coreEvent = createCoreData(this, x, y);\r\n\r\n    log('DraggableCore: handleDragStart: %j', coreEvent);\r\n\r\n    // Call event handler. If it returns explicit false, cancel.\r\n    log('calling', this.props.onStart);\r\n    const shouldUpdate = this.props.onStart(e, coreEvent);\r\n    if (shouldUpdate === false) return;\r\n\r\n    // Add a style to the body to disable user-select. This prevents text from\r\n    // being selected all over the page.\r\n    if (this.props.enableUserSelectHack) addUserSelectStyles(ownerDocument);\r\n\r\n    // Initiate dragging. Set the current x and y as offsets\r\n    // so we know how much we've moved during the drag. This allows us\r\n    // to drag elements around even if they have been moved, without issue.\r\n    this.setState({\r\n      dragging: true,\r\n\r\n      lastX: x,\r\n      lastY: y\r\n    });\r\n\r\n    // Add events to the document directly so we catch when the user's mouse/touch moves outside of\r\n    // this element. We use different events depending on whether or not we have detected that this\r\n    // is a touch-capable device.\r\n    addEvent(ownerDocument, dragEventFor.move, this.handleDrag);\r\n    addEvent(ownerDocument, dragEventFor.stop, this.handleDragStop);\r\n  };\r\n\r\n  handleDrag: EventHandler<MouseTouchEvent> = (e) => {\r\n\r\n    // Prevent scrolling on mobile devices, like ipad/iphone.\r\n    if (e.type === 'touchmove') e.preventDefault();\r\n\r\n    // Get the current drag point from the event. This is used as the offset.\r\n    const position = getControlPosition(e, this.state.touchIdentifier, this);\r\n    if (position == null) return;\r\n    let {x, y} = position;\r\n\r\n    // Snap to grid if prop has been provided\r\n    if (Array.isArray(this.props.grid)) {\r\n      let deltaX = x - this.state.lastX, deltaY = y - this.state.lastY;\r\n      [deltaX, deltaY] = snapToGrid(this.props.grid, deltaX, deltaY);\r\n      if (!deltaX && !deltaY) return; // skip useless drag\r\n      x = this.state.lastX + deltaX, y = this.state.lastY + deltaY;\r\n    }\r\n\r\n    const coreEvent = createCoreData(this, x, y);\r\n\r\n    log('DraggableCore: handleDrag: %j', coreEvent);\r\n\r\n    // Call event handler. If it returns explicit false, trigger end.\r\n    const shouldUpdate = this.props.onDrag(e, coreEvent);\r\n    if (shouldUpdate === false) {\r\n      try {\r\n        // $FlowIgnore\r\n        this.handleDragStop(new MouseEvent('mouseup'));\r\n      } catch (err) {\r\n        // Old browsers\r\n        const event = ((document.createEvent('MouseEvents'): any): MouseTouchEvent);\r\n        // I see why this insanity was deprecated\r\n        // $FlowIgnore\r\n        event.initMouseEvent('mouseup', true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\r\n        this.handleDragStop(event);\r\n      }\r\n      return;\r\n    }\r\n\r\n    this.setState({\r\n      lastX: x,\r\n      lastY: y\r\n    });\r\n  };\r\n\r\n  handleDragStop: EventHandler<MouseTouchEvent> = (e) => {\r\n    if (!this.state.dragging) return;\r\n\r\n    const position = getControlPosition(e, this.state.touchIdentifier, this);\r\n    if (position == null) return;\r\n    const {x, y} = position;\r\n    const coreEvent = createCoreData(this, x, y);\r\n\r\n    const thisNode = ReactDOM.findDOMNode(this);\r\n    if (thisNode) {\r\n      // Remove user-select hack\r\n      if (this.props.enableUserSelectHack) removeUserSelectStyles(thisNode.ownerDocument);\r\n    }\r\n\r\n    log('DraggableCore: handleDragStop: %j', coreEvent);\r\n\r\n    // Reset the el.\r\n    this.setState({\r\n      dragging: false,\r\n      lastX: NaN,\r\n      lastY: NaN\r\n    });\r\n\r\n    // Call event handler\r\n    this.props.onStop(e, coreEvent);\r\n\r\n    if (thisNode) {\r\n      // Remove event handlers\r\n      log('DraggableCore: Removing handlers');\r\n      removeEvent(thisNode.ownerDocument, dragEventFor.move, this.handleDrag);\r\n      removeEvent(thisNode.ownerDocument, dragEventFor.stop, this.handleDragStop);\r\n    }\r\n  };\r\n\r\n  onMouseDown: EventHandler<MouseTouchEvent> = (e) => {\r\n    dragEventFor = eventsFor.mouse; // on touchscreen laptops we could switch back to mouse\r\n\r\n    return this.handleDragStart(e);\r\n  };\r\n\r\n  onMouseUp: EventHandler<MouseTouchEvent> = (e) => {\r\n    dragEventFor = eventsFor.mouse;\r\n\r\n    return this.handleDragStop(e);\r\n  };\r\n\r\n  // Same as onMouseDown (start drag), but now consider this a touch device.\r\n  onTouchStart: EventHandler<MouseTouchEvent> = (e) => {\r\n    // We're on a touch device now, so change the event handlers\r\n    dragEventFor = eventsFor.touch;\r\n\r\n    return this.handleDragStart(e);\r\n  };\r\n\r\n  onTouchEnd: EventHandler<MouseTouchEvent> = (e) => {\r\n    // We're on a touch device now, so change the event handlers\r\n    dragEventFor = eventsFor.touch;\r\n\r\n    return this.handleDragStop(e);\r\n  };\r\n\r\n  render() {\r\n    // Reuse the child provided\r\n    // This makes it flexible to use whatever element is wanted (div, ul, etc)\r\n    return React.cloneElement(React.Children.only(this.props.children), {\r\n      style: styleHacks(this.props.children.props.style),\r\n\r\n      // Note: mouseMove handler is attached to document so it will still function\r\n      // when the user drags quickly and leaves the bounds of the element.\r\n      onMouseDown: this.onMouseDown,\r\n      onTouchStart: this.onTouchStart,\r\n      onMouseUp: this.onMouseUp,\r\n      onTouchEnd: this.onTouchEnd\r\n    });\r\n  }\r\n}"]},"metadata":{},"sourceType":"module"}